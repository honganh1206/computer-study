# Preface

- This book plans to show you **the concrete ways** that concepts underlying all computer systems affect the correctness, performance, and utility of your apps.
- This book is written in **programmerâ€™s perspective** by describing how programmers can use their knowledge of a system to write better programs

> [!important]
> 
> Learning the concepts in this book will help you become the **rare power programmer** who knows how things work and how to fix them when they break.

## Assumptions about the readerâ€™s background

- This book focuses on systems that can execute x86-64 machine code
- There are special notes to highlight important features in C (which will be the main programming language of this book)
- This book features programming examples that have been compiled and run on Linux systems => Use VMs or WSL2 if you use Windows
- NO ASSUMPTION on prior experience with hardware/machine language/assemly-language programming

## How to read the book

- You learn systems by DOING SYSTEMS (work on concrete problems/write programs that run on systems)
- Each new concept also introduces one or more practical problems for you to work on, with solutions at the end of each chapter
- Each homework problem has a specific amount of effort required:
	- ðŸ”º A few minutes with little/no programming experience required
	- ðŸ”º ðŸ”º 20 minutes + writing and testing code
	- ðŸ”º ðŸ”º ðŸ”º 1-2 hours + writing and testing a quite amount of code
	- ðŸ”º ðŸ”º ðŸ”º ðŸ”º Lab assignment - Up to 10 hours of effort
- Source code is available on [this website](http://csapp.cs.cmu.edu/3e/students.html)

```bash
# How to run c code
gcc -o [executable_name] [source_file].c
./[executable_name]
```

- There are **Web asides** containing material that supplements the main presentation of the book in the form of **CHAP:TOP** (chapter subject - topic covered) e.g., DATA:BOOL for supplementary material on Boolean algebra for the presentation of data in Chapter 2

> [!tip] Asides
> Asides are parenthetical remarks that give you some **additional insight** into the current topic.
> 

## Overview of the book

- [[Chapter 1 - A Tour of Computer Systems]]: Introduce the major ideas and themes in computer systems
- Chapter 2: 
	- Computer arithmetic
	- Twoâ€™s-complement (represent signed integers in binary form)
	- How numbers are represented
	- What range of values can be encoded for a given word size
	- Effect of casting between signed and unsigned numbers
	- Mathematical properties of arithmetic operations
- [[Chapter 3]]:
	- How to read x86-64 machine code generated by a C compiler
	- Implementation of procedures (stack allocation, register usage conventions, and parameter passing)
	- Integer and floating-point arithmetic
	- Use of machine-level view of programs to understand common code security vulnerabilities
- [[Chapter 4]]:
	- Basic combinational and sequential logic elements and how these elements can be combined
	- Pipelining: How different steps are structured to process an instruction as separate stages
	- HCL - A hardware description language to describe the control logic for the processor designs
- Chapter 5:
	- Techniques to improve code performance - Learn how to write C code so that a compiler can generate efficient machine code
	- How to measure potential performance of a program through a graphical representation of a program
- [[Chapter 6]]:
	- Cover the different types of RAM and ROM memories + the geometry and organization of magnetic-disk and SSD => Explore how these storage devices are arranged in a hierarchy
	- Learn how to improve appâ€™s performance by improving their temporal (accessed data/instruction likely to be accessed again) and spatial locality (memory locations around the accessed one will likely to be accessed)
- [[Chapter 7]]:
	- **Static and dynamic linking** to resolve confusing errors like glitches during linking for large software packages + understand how object files produced by linkers are tied to loading/virtual memory/memory mapping/etc.
- Chapter 8:
	- Exceptional control flow i.e., changes in control flow outside the normal branches + procedure calls
	- Process - Abstraction of an executing program => Goal: A simple Linux shell with job control to introduce the non-deterministic behavior with concurrent program execution
- [[Chapter 9]]:
	- Understand how the virtual memory works and its characteristics
	- Learn how different simultaneous processes can use an identical range of addresses, sharing some pages but having individual copies of others
	- Learn how to manage and manipulate virtual memory
	- Understand the effects of programs containing memory referencing (process of accessing and manipulating data stored in memory) errors
	- Learn the benefits of covering both the hardware and the software in a unified way
- Chapter 10:
	- Learn basic concepts of Unix I/O like files and descriptors
	- Develop an I/O package to deal with short count (where the library function reads of *part* of the input data)
	- C standard I/O library and its relationship with Linux I/O
- [[Chapter 11]]:
	- Learn how networks tie together concepts we study earlier (processes, signals, byte ordering, etc.)
	- Learn to write a simple Web server
- [[Chapter 12]]:
	-  Concurrent programming with Internet server design as an example
	-  Three basic mechanisms for writing concurrent programs - processes, I/O multiplexing, and threads
	- Basic principles of synchronization
	- Thread-level programming to learn parallelism